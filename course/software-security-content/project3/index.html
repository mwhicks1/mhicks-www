<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><meta name="generator" content="Hugo 0.148.2"/><title>Project 3: White Box and Black Box Fuzz Testing | Hugo Apéro</title><meta property="twitter:site" content="@michael_w_hicks"/><meta property="twitter:creator" content="@michael_w_hicks"/><meta name="description" content="A modern, beautiful, and easily configurable blog theme for Hugo."/><meta property="og:site_name" content="Hugo Apéro"/><meta property="og:title" content="Project 3: White Box and Black Box Fuzz Testing | Hugo Apéro"/><meta property="og:description" content="A modern, beautiful, and easily configurable blog theme for Hugo."/><meta property="og:type" content="page"/><meta property="og:url" content="https://mhicks.me/course/software-security-content/project3/"/><meta property="og:locale" content="en"/><meta property="og:image" content="https://mhicks.me/img/papillons.jpg"/><meta property="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://mhicks.me/img/papillons.jpg"/><meta itemprop="name" content="Project 3: White Box and Black Box Fuzz Testing"/><meta itemprop="description" content="Week 5 presents static analysis and symbolic execution as two techniques for automatically finding security bugs (and other bugs) in programs.
In this lab, we will play with a symbolic executor called KLEE, an open source symbolic execution engine built on top of the LLVM compiler framework. We will compare KLEE’s ability to find memory errors to that of black box fuzzing tool, called radamsa that we see a bit more during week 6."/><meta itemprop="datePublished" content="2015-01-01T00:00:00+00:00"/><meta itemprop="dateModified" content="2015-01-01T00:00:00+00:00"/><meta itemprop="wordCount" content="1503"/><!--[if IE]&gt;&lt;script src=//html5shiv.googlecode.com/svn/trunk/html5.js&gt;&lt;/script&gt;&lt;![endif]--><link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon"/><link rel="icon" href="img/favicon.ico" type="image/x-icon"/><link rel="stylesheet" href="/style.main.min.258343044ddfb33c72268535d36d8d42ea11af827560eaf11cebadca3821dcaa.css" integrity="sha256-JYNDBE3fszxyJoU1022NQuoRr4J1YOrxHOutyjgh3Ko=" media="screen"/><script src="/panelset.min.ed1ac24b6e16f4e2481e3d1d098ae66f5bc77438aef619e6e266d8ac5b00dc72.js" type="text/javascript"></script><script src="/main.min.f3557139a19a73c40c3108b6302a28f27b1c34f3306c920221b3f006123e37ce.js" type="text/javascript"></script></head><body><div class="grid-container single"><header class="site-header pt4 pb2 mb4 bb b--transparent ph5 headroom z-max" role="banner"><nav class="site-nav db dt-l w-100" role="navigation"><a class="site-brand db dtc-l v-mid link no-underline w-100 w-33-l tc tl-l" href="https://mhicks.me/" title="Home"><i class="fas fa-home fa-2x"></i></a><div class="site-links db dtc-l v-mid w-100 w-47-l tc tr-l mt3 mt0-l ttu tracked"><a class="link f6 f5-l dib pv1 ph2" href="/about/" title="About Mike">About</a>
<a class="link f6 f5-l dib pv1 ph2" href="/blog/" title="Blog">Blog</a>
<a class="link f6 f5-l dib pv1 ph2" href="/research/" title="Research">Research</a>
<a class="link f6 f5-l dib pv1 ph2" href="/publication/" title="Publications">Publications</a>
<a class="link f6 f5-l dib pv1 ph2 active" href="/course/" title="Courses">Courses</a></div></nav></header><main class="page-main pa4" role="main"><section class="page-content mw7 center"><article class="post-content pa0 ph4-l"><header class="post-header"><h1 class="f1 lh-solid measure-narrow mb3 fw4">Project 3: White Box and Black Box Fuzz Testing</h1><p class="f6 measure lh-copy mv1">By Mike Hicks</p><p class="f7 db mv0 ttu">January 1, 2015</p></header><section class="post-body pt5 pb4"><p>Week 5 presents static analysis and symbolic execution as two techniques for automatically finding security bugs (and other bugs) in programs.</p><p>In this lab, we will play with a symbolic executor called
<a href="http://klee.github.io/" target="_blank" rel="noopener">KLEE</a>, an open source symbolic execution engine built on top of the
<a href="http://llvm.org/" target="_blank" rel="noopener">LLVM</a> compiler framework. We will compare KLEE’s ability to find memory errors to that of black box fuzzing tool, called
<a href="https://gitlab.com/akihe/radamsa" target="_blank" rel="noopener">radamsa</a> that we see a bit more during week 6.</p><p>We will see that the symbolic executor is able to systematically explore the different control paths of the program, including paths that a black box tool may have difficulty finding. As such, symbolic executors are sometimes called “white box fuzz testers.”</p><h2 id="setup">Setup
<a href="#setup"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>We will be re-using the VM from Project 1. If you did not download that VM, or you have since erased it, directions for installation can be found on the
<a href="../project1">Project 1</a> page.</p><p>We have installed KLEE as a self-contained package in the <strong>klee-cde-package</strong> sub-directory of the <strong>seed</strong> user’s home directory. To use the KLEE binaries we will set your PATH, below, to include the <strong>bin</strong> directory, which is a sub-directory of the root of the KLEE package. Note that because we’ve installed the cde version of the package, to run the KLEE executables you’ll need to add .cde to the end of each executable name, e.g., llvm-gcc.cde and klee.cde. We installed <strong>radamsa</strong> in the usual place (/usr/bin).</p><p>We have created modified versions of the project 1 files, as well as some other scripts to help with this lab. They are in the folder <strong>projects/3</strong> (from the home directory) on the project 1 VM. Enter this directory, and run the following commands.</p><pre tabindex="0"><code>$ make wisdom-alt
$ make wisdom-alt2
</code></pre><p>These will build the <strong>wisdom-alt</strong> and <strong>wisdom-alt2</strong> executables in this directory.</p><p>Run all the following examples from this directory. Now go through each of the steps below, noting your answers, and then take the
<a href="/courses/software-security/assets/week5_fuzz_quiz.docx">project quiz</a>.</p><p>The project 3 files should also be available in
<a href="/courses/software-security/assets/projects.zip">this</a> archive, if you want to download them directly.</p><h2 id="question-1-fuzzing">Question 1: Fuzzing
<a href="#question-1-fuzzing"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>Radamsa is a fuzzer that generates random program inputs by mutating some given input. We have provided a Python script, called <strong>fuzz.py</strong> that connects the output from radamsa to the input of the wisdom program. Radamsa must start with some data to mutate, this data is contained in the <strong>fuzzinput</strong> file.</p><p>Execute the fuzzer against wisdom-alt. Use the command line:</p><pre tabindex="0"><code>$ python fuzz.py ./wisdom-alt &gt; out &amp;&amp; tail out
</code></pre><p>(This runs the fuzzing program to completion, storing its output in the file <strong>out</strong>, and then presenting the last bit of that file. Hit Ctrl-C to get back to the command line.)</p><p>How many iterations does it take the fuzzer to find the bug (i.e., record a crash)? What is the string that it discovers crashes the program?</p><p>See what happens if you change <strong>fuzzinput</strong> to something else and then rerun. Or, try editing fuzz.py and change the seed that is given to radamsa to generate different inputs, to see how that might change things.</p><h2 id="question-2-fuzzing-alt2">Question 2: Fuzzing alt2
<a href="#question-2-fuzzing-alt2"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>The wisdom-alt2.c file is the same as wisdom-alt.c file except that we have added an additional guard restricting the values that can index into ptrs.</p><pre tabindex="0"><code>$ diff wisdom-alt.c wisdom-alt2.c
101,102c101,104
&lt;         fptr tmp = ptrs[s];
&lt;         tmp();
---
&gt;         if(s == 1 || s == 2) {
&gt;           fptr tmp = ptrs[s];
&gt;           tmp();
&gt;         }
</code></pre><p>This change fixes the bug you found in Project 1, by only permitting 1 or 2 to be legal inputs. The question is, How does this impact the effectiveness of the fuzzer?</p><pre tabindex="0"><code>$ python fuzz.py ./wisdom-alt2 &gt; out &amp;&amp; tail out
</code></pre><p>Does this find the bug, i.e. record a crash? If so, in how many iterations?</p><p>Once again, you can adjust the seed value in the script, or try more iterations, to see what happens. (But to answer this question for the quiz leave the seed and iteration count at what they were in the download.)</p><h2 id="question-3-symbolically-executing-wisdom-alt2">Question 3: Symbolically executing wisdom-alt2
<a href="#question-3-symbolically-executing-wisdom-alt2"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>Now let’s try symbolic execution on the program instead. To do this, we have to modify the program to identify which variables KLEE should consider to be symbolic. We also have to make some other cosmetic changes to get things to work properly. The result is in the file wisdom-alt-sym.c.</p><p>You can do <strong>diff wisdom-alt2.c wisdom-alt-sym.c</strong> to see the differences for yourself, but here’s a summary. First, we added a function <strong>sym_gets</strong> that simulates the <strong>gets</strong> library call by filling a buffer with symbolic values, and replace the program’s call to <strong>gets</strong> with a call to this function. Second, we removed the loop that repeatedly requests user input; this speeds up our testing because we only need one input to find the bug, and KLEE will repeatedly explore different (single) inputs. Third, we replaced the command to read the initial input, <strong>read(infd, buf, sizeof(buf)-sizeof(char));</strong> to instead ask KLEE to generate a symbolic value, using <strong>klee_make_symbolic(buf, sizeof(buf), “buf”);</strong></p><p>Now compile the <strong>wisdom-alt-sym</strong> program with the following command line (from within the <strong>project3</strong> directory):</p><pre tabindex="0"><code>$ export PATH=$HOME/klee-cde-package/bin/:$PATH
$ llvm-gcc.cde -I../../klee-cde-package/cde-root/home/pgbovine/klee/include --emit-llvm -c -g wisdom-alt-sym.c
</code></pre><p>(Note that the first option is an uppercase I, not a lowercase L.) Now evaluate it with KLEE using the following command line:</p><pre tabindex="0"><code>$ klee.cde -exit-on-error wisdom-alt-sym.o
</code></pre><p>It should exit shortly and discover the error, printing a stack trace and some information about the current state. It will have created a directory <strong>klee-last</strong> in the current directory that contains further information about the symbolic execution. If you look in there, you will see that it generated some tests and some statistics.</p><p>The (binary) files ending in .ktest in this directory can be formatted intelligibly by using <strong>ktest-tool</strong>. Use the following command line to discover the symbolic state the error occurred in:</p><pre tabindex="0"><code>$ ktest-tool.cde klee-last/test000001.ktest
ktest file : &#39;klee-last/test000001.ktest&#39;
args       : [&#39;wisdom-alt-sym.o&#39;]
num objects: 2
object    0: name: &#39;AAAAAA&#39;
object    0: size: NN
object    0: data: &#39;XXXXXXXX&#39;
object    1: name: &#39;BBBBBBB&#39;
object    1: size: JJ
object    1: data: &#39;XXXXXXXX&#39;
</code></pre><p>We have replaced particular values in the above output with AAA, NN, etc. Which <em>symbolic variables</em> were involved (AAAAAA and BBBBBB in the above)? What was their contents (XXXXXXXX in the above)?</p><h2 id="question-4-symbolically-executing-the-maze">Question 4: Symbolically executing the maze
<a href="#question-4-symbolically-executing-the-maze"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>In a sense, a symbolic executor is exploring a maze defined by the program’s execution space. We can make this analogy a reality by using KLEE to symbolically execute a program that asks its user to solve a maze. This program is taken from a
<a href="http://feliam.wordpress.com/2010/10/07/the-symbolic-maze/" target="_blank" rel="noopener">blog post by Felipe Andres Manzano</a>; I encourage you to check it out to go into more depth about what’s going on.</p><p>The file <strong>maze.c</strong> defines the maze-solving program, and the file <strong>maze-sym.c</strong> is a slightly modified version of it, suitable for running with KLEE. Compile the maze programs both normally and symbolically:</p><pre tabindex="0"><code>$ make maze
$ llvm-gcc.cde -I ../../klee-cde-package/cde-root/home/pgbovine/klee/include --emit-llvm -c -g maze-sym.c
</code></pre><p>Once again, the second version is different from the first in identifying data as symbolic.</p><pre tabindex="0"><code>$ diff maze.c maze-sym.c
10a11
&gt; #include &lt;klee/klee.h&gt;
71c72,73
&lt;     read(0,program,ITERS);
---
&gt;     //read(0,program,ITERS);
&gt;     klee_make_symbolic(program,ITERS,&#34;program&#34;);
</code></pre><p>Here, the variable <strong>program</strong> is a buffer that contains the user’s input; instead of reading it in from the user, the modified program treats the entire buffer as symbolic.</p><p>Run the (normal) maze program and see if you can find a solution to the maze. Then, run the symbolic maze program under KLEE:</p><pre tabindex="0"><code>$ klee.cde maze-sym.o
</code></pre><p>KLEE will work for a while and then end. The maze program will generate an assertion failure when a path through the maze has been identified, so the test that is a winning path through the maze is identified by an assert. Look for the path that solved the maze looking for a file that ends in <strong>err</strong>:</p><pre tabindex="0"><code>$ ls -1 klee-last | grep -A2 -B2 err
test0000AA.ktest
test0000BB.ktest
test0000NN.assert.err
test0000NN.ktest
test0000NN.pc
</code></pre><p>(Note the argument to <strong>ls</strong> is a 1 (one), not a lower-case l.) Here, AA, BB, and NN are numbers that may change depending on your VM setup (on mine, NN is sometimes 62 and sometimes 89). Use the <strong>ktest-tool</strong> on the test0000NN.ktest file (where NN is replaced with numbers from your VM) to see what path KLEE found through the maze.</p><pre tabindex="0"><code>$ ktest-tool.cde klee-last/test0000NN.ktest
ktest file : &#39;klee-last/test0000NN.ktest&#39;
args       : [&#39;maze-sym.o&#39;]
num objects: 1
object    0: name: &#39;program&#39;
object    0: size: MM
object    0: data: &#39;XXXXXXXXXXXXXXXXXXXXXXXXX\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;
</code></pre><p>What was the data (the XXXXetc. part, not including any \x00\x00 parts, if any) for the program object?</p><p>It turns out there are multiple “solutions” to the maze; you can see them all by doing</p><pre tabindex="0"><code>$ klee.cde --emit-all-errors maze-sym.o
</code></pre><p>Then the ls command from above will show all the solutions. How many are there?</p><h2 id="question-5-walking-through-walls">Question 5: Walking through walls
<a href="#question-5-walking-through-walls"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>Are you surprised by the answer to question 4?</p><p>Something funny is going on: somehow the solution is allowed to walk through walls. Look through the code, and find the condition that allows this to happen. What line is it on? Comment it out and try again, to confirm you are getting just one solution.</p><details closed="" class="f6 fw7 input-reset"><dl class="f6 lh-copy"><dt class="fw7">Posted on:</dt><dd class="fw5 ml0">January 1, 2015</dd></dl><dl class="f6 lh-copy"><dt class="fw7">Length:</dt><dd class="fw5 ml0">8 minute read, 1503 words</dd></dl><dl class="f6 lh-copy"><dt class="fw7">See Also:</dt></dl></details></section><footer class="post-footer"><div class="post-pagination dt w-100 mt4 mb2"></div></footer></article></section></main><footer class="site-footer pv4 bt b--transparent ph5" role="contentinfo"><nav class="db dt-l w-100"><p class="site-copyright f7 db dtc-l v-mid w-100 w-33-l tc tl-l pv2 pv0-l mv0 lh-copy">© 2025 RStudio, Anywhere
<span class="middot-divider"></span>
Made with <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/hugo-apero/" rel="dct:source">Hugo Apéro</a></span>.<br/>Based on <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/formspree/blogophonic-hugo" rel="dct:source">Blogophonic</a></span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://formspree.io" property="cc:attributionName" rel="cc:attributionURL">Formspree</a>.</p><div class="site-social-links db dtc-l v-mid w-100 w-33-l tc pv2 pv0-l mv0"><div class="social-icon-links" aria-hidden="true"><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://linkedin.com/in/mike-hicks-a053311/" title="linkedin" target="_blank" rel="me noopener"><i class="fab fa-linkedin fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://github.com/mwhicks1" title="github" target="_blank" rel="me noopener"><i class="fab fa-github fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://scholar.google.com/citations?user=Gggzp7UAAAAJ" title="google-scholar" target="_blank" rel="me noopener"><i class="ai ai-google-scholar fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://dblp.org/pid/h/MichaelWHicks.html" title="dblp" target="_blank" rel="me noopener"><i class="ai ai-dblp fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://orcid.org/0000-0002-2759-9223" title="orcid" target="_blank" rel="me noopener"><i class="ai ai-orcid fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="/blog/index.xml" title="rss"><i class="fas fa-rss fa-lg fa-fw"></i></a></div></div><div class="site-links f6 db dtc-l v-mid w-100 w-67-l tc tr-l pv2 pv0-l mv0"><a class="dib pv1 ph2 link" href="/license/" title="License">License</a>
<a class="dib pv1 ph2 link" href="/contact/" title="Contact form">Contact</a>
<a class="dib pv1 ph2 link" href="/contributors/" title="Contributors">Contributors</a></div></nav><script>var i,text,code,codes=document.getElementsByTagName("code");for(let e=0;e<codes.length;){if(code=codes[e],code.parentNode.tagName!=="PRE"&&code.childElementCount===0&&(text=code.textContent,/^\$[^$]/.test(text)&&/[^$]\$$/.test(text)&&(text=text.replace(/^\$/,"\\(").replace(/\$$/,"\\)"),code.textContent=text),/^\\\((.|\s)+\\\)$/.test(text)||/^\\\[(.|\s)+\\\]$/.test(text)||/^\$(.|\s)+\$$/.test(text)||/^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text))){code.outerHTML=code.innerHTML;continue}e++}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous"/><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script></footer></div></body></html>