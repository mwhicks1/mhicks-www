<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><meta name="generator" content="Hugo 0.148.2"/><title>Week 2: Defenses against low-level attacks | Hugo Apéro</title><meta property="twitter:site" content="@apreshill"/><meta property="twitter:creator" content="@apreshill"/><meta name="description" content="A modern, beautiful, and easily configurable blog theme for Hugo."/><meta property="og:site_name" content="Hugo Apéro"/><meta property="og:title" content="Week 2: Defenses against low-level attacks | Hugo Apéro"/><meta property="og:description" content="A modern, beautiful, and easily configurable blog theme for Hugo."/><meta property="og:type" content="page"/><meta property="og:url" content="https://mhicks.me/course/software-security-content/week2/"/><meta property="og:locale" content="en"/><meta property="og:image" content="https://mhicks.me/img/papillons.jpg"/><meta property="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://mhicks.me/img/papillons.jpg"/><meta itemprop="name" content="Week 2: Defenses against low-level attacks"/><meta itemprop="description" content="We continue our discussion of low-level software security by understanding ways to defend against memory-based attacks like buffer overflows and format string attacks, introduced last week.
Defenses fall into two categories: (1) automatic, and (2) manual (based on disciplined programming styles). We will also look at a sophisticated attack, called return oriented programming, that aims to overcome some of the automatic defenses, as well as an experimental defense against it. In the end, the most sure defense against low level attacks is to program with a memory-safe (or better yet, a type-safe) programming language in the situations that’s possible."/><meta itemprop="datePublished" content="2015-01-01T00:00:00+00:00"/><meta itemprop="dateModified" content="2015-01-01T00:00:00+00:00"/><meta itemprop="wordCount" content="1622"/><!--[if IE]&gt;&lt;script src=//html5shiv.googlecode.com/svn/trunk/html5.js&gt;&lt;/script&gt;&lt;![endif]--><link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon"/><link rel="icon" href="img/favicon.ico" type="image/x-icon"/><link rel="stylesheet" href="/style.main.min.2865f5646a2fa1d343d422f013dfab2b6cea4ac451ad519d65648417e70390d9.css" integrity="sha256-KGX1ZGovodND1CLwE9+rK2zqSsRRrVGdZWSEF+cDkNk=" media="screen"/><script src="/panelset.min.ed1ac24b6e16f4e2481e3d1d098ae66f5bc77438aef619e6e266d8ac5b00dc72.js" type="text/javascript"></script><script src="/main.min.f3557139a19a73c40c3108b6302a28f27b1c34f3306c920221b3f006123e37ce.js" type="text/javascript"></script></head><body><div class="grid-container single"><header class="site-header pt4 pb2 mb4 bb b--transparent ph5 headroom z-max" role="banner"><nav class="site-nav db dt-l w-100" role="navigation"><a class="site-brand db dtc-l v-mid link no-underline w-100 w-33-l tc tl-l" href="https://mhicks.me/" title="Home"><img src="/img/blogophonic-mark-dark.png" class="dib db-l h2 w-auto" alt="Hugo Apéro"/></a><div class="site-links db dtc-l v-mid w-100 w-47-l tc tr-l mt3 mt0-l ttu tracked"><a class="link f6 f5-l dib pv1 ph2" href="/about/" title="About Blogophonic">About</a>
<a class="link f6 f5-l dib pv1 ph2" href="/blog/" title="Blog">Blog</a>
<a class="link f6 f5-l dib pv1 ph2" href="/project/" title="Project Portfolio">Projects</a>
<a class="link f6 f5-l dib pv1 ph2" href="/publication/" title="Publications">Publications</a>
<a class="link f6 f5-l dib pv1 ph2 active" href="/course/" title="Courses">Courses</a>
<a class="link f6 f5-l dib pv1 ph2" href="/elements/" title="Element Page">Elements</a></div></nav></header><main class="page-main pa4" role="main"><section class="page-content mw7 center"><article class="post-content pa0 ph4-l"><header class="post-header"><h1 class="f1 lh-solid measure-narrow mb3 fw4">Week 2: Defenses against low-level attacks</h1><p class="f6 measure lh-copy mv1">By Mike Hicks</p><p class="f7 db mv0 ttu">January 1, 2015</p></header><section class="post-body pt5 pb4"><p>We continue our discussion of low-level software security by understanding ways to defend against memory-based attacks like buffer overflows and format string attacks, introduced last week.</p><p>Defenses fall into two categories: (1) <em>automatic</em>, and (2) <em>manual</em> (based on disciplined programming styles). We will also look at a sophisticated attack, called <em>return oriented programming</em>, that aims to overcome some of the automatic defenses, as well as an experimental defense against it. In the end, the most sure defense against low level attacks is to program with a <em>memory-safe</em> (or better yet, a <em>type-safe</em>) programming language in the situations that’s possible.</p><h2 id="learning-objectives">Learning Objectives
<a href="#learning-objectives"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>After the completion of this week’s material, you will be able to:</p><ul><li>Comprehend the meaning of the properties <em>memory safety</em>, and <em>type safety</em> and why programs enjoying these properties are immune from memory based attacks</li><li>Understand several common automatic defenses against memory-based attacks, including <em>stack canaries, data execution protection (DEP)</em>, and <em>address space layout randomization (ASLR)</em></li><li>Understand how attacks based on <em>return-oriented programming (ROP)</em> work</li><li>Understand the concept of <em>control-flow integrity (CFI)</em> and how it can defeat ROP-based attacks</li><li>Understand a series of rules of thumb for programming in C so as to avoid memory-based attacks</li></ul><h2 id="video-lectures">Video Lectures
<a href="#video-lectures"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><ul><li><a href="https://youtu.be/kL6T8KvKrk0" target="_blank" rel="noopener">Defenses Against Low-Level Attacks: Introduction</a> (2:58)</li><li><a href="https://youtu.be/A-SVeu0ZKI4" target="_blank" rel="noopener">Memory Safety</a> (16:56)</li><li><a href="https://youtu.be/q_vB6WyP16o" target="_blank" rel="noopener">Type Safety</a> (4:39)</li><li><a href="https://youtu.be/pObdbiQJpsk" target="_blank" rel="noopener">Avoiding Exploitation</a> (9:38)</li><li><a href="https://youtu.be/1dTF_Np9Lcw" target="_blank" rel="noopener">Return-Oriented Programming</a> (11:30)</li><li><a href="https://youtu.be/lrkNs5qo5Cw" target="_blank" rel="noopener">Control-Flow Integrity</a> (14:51)</li><li><a href="https://youtu.be/A-6nVxB3F5M" target="_blank" rel="noopener">Secure Coding</a> (18:29)</li></ul><h2 id="required-readings">Required Readings
<a href="#required-readings"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>The following two blog posts cover the topics of memory safety and type safety in somewhat greater depth:</p><ul><li><a href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/" target="_blank" rel="noopener">What is memory safety?</a></li><li><a href="http://www.pl-enthusiast.net/2014/08/05/type-safety/" target="_blank" rel="noopener">What is type safety?</a></li></ul><h2 id="quiz">Quiz
<a href="#quiz"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>The
<a href="/course/software-security/assets/week2_quiz.docx">quiz for this week</a> covers all of this week’s material.</p><h2 id="supplemental-readings-and-links">Supplemental readings and links
<a href="#supplemental-readings-and-links"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>The following readings are optional: Check them out if you are interested in learning more about material we’ve covered in lecture (many were explicitly linked in the lecture slides).</p><h3 id="attacks-and-modern-defenses-generally">Attacks and modern defenses, generally
<a href="#attacks-and-modern-defenses-generally"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><ul><li><a href="http://cseweb.ucsd.edu/~hovav/papers/sppgmb04.html" target="_blank" rel="noopener">On the effectiveness of Address Space Randomization</a>, by Shacham, Page, Pfaff, Goh, Modadugu, and Boneh - showed how ASLR implementations on 32-bit systems can be defeated relatively easily</li><li><a href="http://paulmakowski.wordpress.com/2011/01/25/smashing-the-stack-in-2011/" target="_blank" rel="noopener">Smashing the Stack in 2011</a> - Paul Makowski revisits the
<a href="http://insecure.org/stf/smashstack.html" target="_blank" rel="noopener">1996 Aleph One article</a> (on the supplemental reading list from last week), considering defenses at that time</li><li><a href="http://www.google.com/search?lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Low-Level+Software+Security+by+Example+Erlingsson+Younan+Piessens" target="_blank" rel="noopener">Low-level software security by example</a>, by Erlingsson, Younan, Piessens, describes several low-level attacks and defenses.</li></ul><h3 id="return-oriented-programming-rop">Return-oriented Programming (ROP)
<a href="#return-oriented-programming-rop"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><ul><li><a href="https://cseweb.ucsd.edu/~hovav/dist/geometry.pdf" target="_blank" rel="noopener">Geometry of Innocent Flesh on the Bone: Return to libc without Function Calls (on the x86)</a>, by Hovav Shacham - introduced the idea, and the term, return oriented programming</li><li><a href="https://www.usenix.org/legacy/event/sec11/tech/full_papers/Schwartz.pdf" target="_blank" rel="noopener">Q: Exploit Hardening Made Easy</a>, by Schwartz, Avgerinos, and Brumley - explains how to automatically generate ROP exploits</li><li><a href="http://www.scs.stanford.edu/brop/" target="_blank" rel="noopener">Blind ROP</a> - return-oriented programming without source code, automatically</li></ul><h3 id="control-flow-integrity-cfi">Control-flow integrity (CFI)
<a href="#control-flow-integrity-cfi"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><ul><li><a href="http://research.microsoft.com/pubs/64250/ccs05.pdf" target="_blank" rel="noopener">Control Flow Integrity</a>, by Abadi, Budiu, Erlingsson, and Ligatti - paper that introduced CFI</li><li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html" target="_blank" rel="noopener">CFI in Clang/LLVM</a> - modern versions of the Clang/LLVM compiler will introduce various kinds of CFI support via compilation flags.
<a href="https://www.redhat.com/en/blog/fighting-exploits-control-flow-integrity-cfi-clang" target="_blank" rel="noopener">RedHat has a nice tutorial description of it</a>.</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard" target="_blank" rel="noopener">Microsoft’s Control Flow Guard (CFG)</a> implements a CFI-style defense to Visual Studio projects; it is used when building the distributed executables of Internet Explorer and the Edge browser. Some discussion about CFG as compared to CFI is given in this
<a href="https://blog.trailofbits.com/2016/12/27/lets-talk-about-cfi-microsoft-edition/" target="_blank" rel="noopener">blog post</a>. Both
<a href="https://msrc-blog.microsoft.com/2020/08/17/control-flow-guard-for-clang-llvm-and-rust/" target="_blank" rel="noopener">CFG and CFI are now available in Clang/LLVM</a>.</li><li>See also the paper <em>Low-level software security by example</em>, above.</li></ul><h3 id="secure-coding">Secure coding
<a href="#secure-coding"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><p>These are a few references linked in the lecture slides. We will cover secure coding and design in more depth during week 4.</p><ul><li><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C coding standard</a></li><li><a href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/internals.html" target="_blank" rel="noopener">Secure Programming HOWTO</a> by David Wheeler</li><li><a href="http://nob.cs.ucdavis.edu/bishop/secprog/robust.html" target="_blank" rel="noopener">Robust Programming</a> by Matt Bishop</li><li><a href="http://plasma.cs.umass.edu/emery/diehard.html" target="_blank" rel="noopener">DieHard project</a> - drop-in replacement for malloc that uses randomization to defend against heap-based exploits</li></ul><h2 id="project">Project
<a href="#project"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>There is <strong>no new project</strong> this week. Don’t forget to complete
<a href="../project1">Project 1</a> on exploiting buffer overflows. Take the
<a href="/courses/software-security/assets/week1_BOF_quiz.docx">project quiz</a> when you have completed that project.</p><h2 id="notes-on-course-content">Notes on Course Content
<a href="#notes-on-course-content"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h2><p>Writing in October 2020, a number of things have changed since 2015. Here are some of them.</p><h3 id="enforcing-memory-safety">Enforcing Memory Safety
<a href="#enforcing-memory-safety"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><p>In the lecture, I wrote “coming soon, Intel MPX!” Since then, Intel MPX has come … and gone. As summarized on the
<a href="https://en.wikipedia.org/wiki/Intel_MPX" target="_blank" rel="noopener">Wikipedia MPX page</a>, “In practice, there have been too many flaws discovered in the design for it to be useful, and support has been deprecated or removed from most compilers and operating systems.” As a specific example, the gcc compiler used to provide a compiler extension that could take advantage of the MPX instructions, but that
<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=MPX-Removed-From-GCC9/" target="_blank" rel="noopener">support has now been deprecated</a>. A key problem is that the extra hardware doesn’t actually improve performance over software-only implementations, and in some cases performance could be worse!</p><p>The
<a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/" target="_blank" rel="noopener"><strong>CHERI (Capability Hardware Enhanced RISC Instructions)</strong></a> project is a more promising alternative. It defines a set of hardware extensions that provide capabilities, which can be used for enforcing memory safety. Initial designs targeted just spatial safety, but later work targeted temporal safety as well. Ongoing effort has focused on developing a
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf" target="_blank" rel="noopener">C compiler that targets CHERI</a>.</p><p><strong>In</strong> late 2015 Microsoft began developing
<a href="https://www.checkedc.org/" target="_blank" rel="noopener"><strong>Checked C</strong></a>, an extension to C that aims to ensure spatial safety (and, to a degree, type safety); it has since been forked and is run by an independent foundation. Checked C is implemented as an
<a href="https://github.com/microsoft/checkedc-clang" target="_blank" rel="noopener">extension to the open-source Clang/LLVM compiler</a>; the compiler inserts run-time checks when needed for enforcing safety. Recent work (e.g,. in a
<a href="https://cs.rochester.edu/u/jzhou41/papers/freebsd_checkedc.pdf" target="_blank" rel="noopener">partial refactor of the FreeBSD operating system to use Checked C</a>) shows such checks to be relatively inexpensive, e.g., around a few percent. Of course, the compiler is still under development so things may change. I think very highly of this effort, so I am working with the Checked C team both to design the language and to develop tools to automatically migrate legacy C code to Checked C.</p><p>Another mature effort to <strong>ensure partial memory safety is</strong>
<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener"><strong>Address Sanitizer (ASAN)</strong></a>, but ASAN-ized code is much slower (e.g., 2x slowdown) with checks inserted, so it would not normally be used in production.</p><h3 id="enforcing-type-safety">Enforcing Type Safety
<a href="#enforcing-type-safety"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><p>In the lecture, I said that modern languages are emerging that aim to ensure type safety while also providing good performance. I mentioned
<a href="https://golang.org/" target="_blank" rel="noopener">Go</a>,
<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust</a>, and
<a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">Swift</a>, in particular. Since 2015, all three of these languages have become better developed and more popular. Indeed, I would say that <strong>Rust has emerged as a strong contender to be the “go to” safe systems programming language</strong>. Rust’s notion of type safety implies not only memory safety, but also freedom from
<a href="https://blog.regehr.org/archives/490" target="_blank" rel="noopener">data races</a>. These owe to defects in concurrent programs, are difficult to find and debug, and can have security implications; Rust’s type system ensures their absence. Developers love these benefits among others: According to Stack Overflow’s annual poll of developers,
<a href="https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/" target="_blank" rel="noopener">Rust has been the year’s “most loved” language for five years in row</a>!</p><h3 id="avoiding-exploitation">Avoiding Exploitation
<a href="#avoiding-exploitation"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><p>In the lecture, I talked about several defenses that aim to make memory safety bugs harder to exploit, e.g., address space layout randomization (ASLR) and stack canaries. These defenses are still relevant today, but have evolved while facing new threats.</p><p>Using the Clang/LLVM compiler, stack canaries are enabled with the -fstack-protector flag. It also provides another defense called
<a href="https://en.wikipedia.org/wiki/Shadow_stack" target="_blank" rel="noopener"><em>shadow stacks</em></a><strong>, which has the same goal as stack canaries but is more dependable</strong>, while still being low overhead. The basic idea is to separate critical metadata, notably return addresses, into a separate stack so that it will not be overwritten by a stack-based buffer overflow. The
<a href="https://clang.llvm.org/docs/SafeStack.html" target="_blank" rel="noopener">Clang/LLVM compiler’s -fsanitize=safe-stack flag enables shadow stacks</a> (called “safe stacks”); the gcc compiler supports them as well.</p><p>ASLR is widely deployed, e.g., on
<a href="https://www.networkworld.com/article/3331199/what-does-aslr-do-for-linux.html" target="_blank" rel="noopener">Linux</a>, MacOS, IOS, and
<a href="https://techcommunity.microsoft.com/t5/windows-10-security/turn-on-mandatory-aslr-in-windows-security/m-p/1186989" target="_blank" rel="noopener">Windows</a> (though for the last it is turned off by default). ASLR is effective when the base addresses of randomized process memory segments are hard to guess. A common part of an attack against an ASLR-protected system is to exploit a bug that leaks a base address. Software and hardware side channels, e.g., due to caches, are a
<a href="http://www.minemu.org/papers/anc_ndss17.pdf" target="_blank" rel="noopener">vector for such leaks</a>. Indeed, as mentioned last week, the
<a href="https://spectreattack.com/" target="_blank" rel="noopener">Spectre and Meltdown bugs</a> have shown that hardware-based side channels are a significant threat. Moreover, recent work has shown that
<a href="https://download.vusec.net/papers/pirop_eurosp18.pdf" target="_blank" rel="noopener">information disclosure is not always needed to defeat ASLR</a>. As such, it remains to be seen whether ASLR remains an effective defense in the future.</p><h3 id="control-flow-integrity-cfi-1">Control Flow Integrity (CFI)
<a href="#control-flow-integrity-cfi-1"><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22"><path d="M0 0h24v24H0z" fill="currentColor"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a></h3><p>In 2015, CFI was being seriously explored as a viable defense. Full CFI, as originally proposed, added too much performance overhead, so researchers were exploring less expensive alternatives with less protection. I updated the links in the supplemental material, above, to discuss CFI a bit more.</p><p>The
<a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html" target="_blank" rel="noopener"><strong>Clang/LLVM compiler supports CFI</strong></a> <strong>in various forms</strong>;
<a href="https://blog.trailofbits.com/2016/10/17/lets-talk-about-cfi-clang-edition/" target="_blank" rel="noopener">Trail of Bits has written a nice tutorial about it</a>. One variant is
<a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/tice" target="_blank" rel="noopener">forward-edge only CFI</a> (FO-CFI), which does not protect returns via addresses on the stack, but does protect calls via function pointers and virtual method tables. (Shadow stacks could be enabled, at low cost, to provide protection for return addresses.) For FO-CFI, “a performance overhead of less than 1% has been measured by running the Dromaeo benchmark suite against an instrumented version of the Chromium web browser.”
<a href="https://nebelwelt.net/blog/20181226-CFIeval.html" target="_blank" rel="noopener">Mathias Payer also did a detailed study of Clang/LLVM CFI</a>, and found per-dispatch overheads at around 20% (but forward-edge dispatches are relatively infrequent operations in the code). The
<a href="https://www.chromium.org/developers/testing/control-flow-integrity" target="_blank" rel="noopener">Chrome team planned to include Clang’s CFI protections in the browser</a>. (Note that
<a href="https://blog.llvm.org/2018/03/clang-is-now-used-to-build-chrome-for.html" target="_blank" rel="noopener">clang is used to build Chrome for Windows</a>, too.)</p><p>The flip side of the lowered overhead is the lowered protection. How low is too low?
<a href="https://arxiv.org/pdf/1910.01485.pdf" target="_blank" rel="noopener">Muntean et al developed an empirical framework for evaluating the different levels of protection offered by CFI</a> which aims to determine the post-CFI-protected attack surface on particular applications; for example, it will determine the number of possible allowed targets per callsite, for each CFI policy (fewer is better). These surfaces can then be compared to understand a ranking of the offered defense, compared to its overhead.</p><details closed="" class="f6 fw7 input-reset"><dl class="f6 lh-copy"><dt class="fw7">Posted on:</dt><dd class="fw5 ml0">January 1, 2015</dd></dl><dl class="f6 lh-copy"><dt class="fw7">Length:</dt><dd class="fw5 ml0">8 minute read, 1622 words</dd></dl><dl class="f6 lh-copy"><dt class="fw7">See Also:</dt></dl></details></section><footer class="post-footer"><div class="post-pagination dt w-100 mt4 mb2"></div></footer></article></section></main><footer class="site-footer pv4 bt b--transparent ph5" role="contentinfo"><nav class="db dt-l w-100"><p class="site-copyright f7 db dtc-l v-mid w-100 w-33-l tc tl-l pv2 pv0-l mv0 lh-copy">© 2025 RStudio, Anywhere
<span class="middot-divider"></span>
Made with <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/hugo-apero/" rel="dct:source">Hugo Apéro</a></span>.<br/>Based on <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/formspree/blogophonic-hugo" rel="dct:source">Blogophonic</a></span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://formspree.io" property="cc:attributionName" rel="cc:attributionURL">Formspree</a>.</p><div class="site-social-links db dtc-l v-mid w-100 w-33-l tc pv2 pv0-l mv0"><div class="social-icon-links" aria-hidden="true"><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://linkedin.com/in/mike-hicks-a053311/" title="linkedin" target="_blank" rel="me noopener"><i class="fab fa-linkedin fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://github.com/mwhicks1" title="github" target="_blank" rel="me noopener"><i class="fab fa-github fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://scholar.google.com/citations?user=Gggzp7UAAAAJ" title="google-scholar" target="_blank" rel="me noopener"><i class="ai ai-google-scholar fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://dblp.org/pid/h/MichaelWHicks.html" title="dblp" target="_blank" rel="me noopener"><i class="ai ai-dblp fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="https://orcid.org/0000-0002-2759-9223" title="orcid" target="_blank" rel="me noopener"><i class="ai ai-orcid fa-lg fa-fw"></i>
</a><a class="link dib h1 w1 ml0 mr2 f6 o-90 glow" href="/blog/index.xml" title="rss"><i class="fas fa-rss fa-lg fa-fw"></i></a></div></div><div class="site-links f6 db dtc-l v-mid w-100 w-67-l tc tr-l pv2 pv0-l mv0"><a class="dib pv1 ph2 link" href="/license/" title="License">License</a>
<a class="dib pv1 ph2 link" href="/contact/" title="Contact form">Contact</a>
<a class="dib pv1 ph2 link" href="/contributors/" title="Contributors">Contributors</a></div></nav><script>var i,text,code,codes=document.getElementsByTagName("code");for(let e=0;e<codes.length;){if(code=codes[e],code.parentNode.tagName!=="PRE"&&code.childElementCount===0&&(text=code.textContent,/^\$[^$]/.test(text)&&/[^$]\$$/.test(text)&&(text=text.replace(/^\$/,"\\(").replace(/\$$/,"\\)"),code.textContent=text),/^\\\((.|\s)+\\\)$/.test(text)||/^\\\[(.|\s)+\\\]$/.test(text)||/^\$(.|\s)+\$$/.test(text)||/^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text))){code.outerHTML=code.innerHTML;continue}e++}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous"/><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script></footer></div></body></html>